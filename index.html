<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scope API Test - Text Display Control</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      align-items: flex-start;
    }

    #controls {
      width: 400px;
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
    }

    h1 {
      font-size: 18px;
      margin-bottom: 20px;
      color: #00ff88;
    }

    #status {
      padding: 10px;
      background: #222;
      border-radius: 4px;
      margin-bottom: 10px;
      font-family: monospace;
      font-size: 12px;
      color: #888;
    }

    #status.connected {
      color: #00ff88;
    }

    #status.error {
      color: #ff4444;
    }

    .control-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      background: #222;
      border: 1px solid #333;
      border-radius: 4px;
      color: #fff;
      font-size: 14px;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #00ff88;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #00ff88;
      border-radius: 50%;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #00ff88;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .slider-value {
      display: inline-block;
      float: right;
      font-size: 12px;
      color: #00ff88;
      font-weight: 600;
    }

    .color-preview {
      width: 100%;
      height: 40px;
      border-radius: 4px;
      margin-top: 10px;
      border: 1px solid #333;
    }

    button {
      width: 100%;
      padding: 12px;
      background: #00ff88;
      color: #000;
      border: none;
      border-radius: 4px;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    button:hover {
      background: #00dd77;
    }

    button:active {
      background: #00bb66;
    }

    .info {
      margin-top: 20px;
      padding: 15px;
      background: #222;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
      color: #888;
    }

    .info code {
      background: #333;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      color: #00ff88;
    }

    .connect-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }

    .connect-row input[type="text"] {
      flex: 1;
      min-width: 0;
    }

    .connect-row button {
      width: auto;
      padding: 10px 16px;
      font-size: 13px;
      white-space: nowrap;
    }

    .port-note {
      margin-top: 6px;
      font-size: 11px;
      color: #555;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h1>üé® Scope Control</h1>

    <div class="control-group">
      <label>Scope Server</label>
      <div class="connect-row">
        <input type="text" id="serverPort" value="localhost:8000" placeholder="localhost:8000">
        <button id="connectBtn">Connect</button>
      </div>
      <div class="port-note">Local: <code>localhost:8000</code> ¬∑ RunPod: <code>abc123-8000.proxy.runpod.net</code></div>
    </div>

    <div class="control-group">
      <label>Pipeline</label>
      <select id="pipelineSelect" style="width:100%;padding:10px;background:#222;border:1px solid #333;border-radius:4px;color:#fff;font-size:14px;">
        <option value="longlive">longlive</option>
        <option value="passthrough">passthrough</option>
        <option value="text-display">text-display</option>
      </select>
    </div>

    <div id="status">Not connected</div>

    <!-- longlive controls -->
    <div id="ui-longlive">
      <div class="control-group">
        <label>Prompt</label>
        <input type="text" id="promptInput" placeholder="Enter prompt...">
      </div>
      <div class="control-group">
        <button id="resetCacheBtn" style="background:#333;color:#aaa;border:1px solid #555;">Reset Cache</button>
      </div>
    </div>

    <!-- passthrough / NDI controls -->
    <div id="ui-passthrough" style="display:none;">
      <div class="control-group">
        <label style="display:flex; justify-content:space-between; align-items:center;">
          NDI Source
          <button id="ndiRefreshBtn" style="width:auto;padding:4px 10px;font-size:11px;background:#333;color:#aaa;border:1px solid #555;">Refresh</button>
        </label>
        <select id="ndiSelect" style="width:100%;padding:10px;background:#222;border:1px solid #333;border-radius:4px;color:#fff;font-size:13px;">
          <option value="">‚Äî click Refresh to scan ‚Äî</option>
        </select>
        <div id="ndiStatus" style="margin-top:6px;font-size:11px;color:#555;font-family:monospace;"></div>
      </div>
    </div>

    <!-- text-display controls -->
    <div id="ui-text-display" style="display:none;">
      <div class="control-group">
        <label>Text Message</label>
        <input type="text" id="textInput" value="Hello Scope!" placeholder="Enter text...">
      </div>

      <div class="control-group">
        <label>
          Text Red
          <span class="slider-value" id="redValue">1.00</span>
        </label>
        <input type="range" id="redSlider" min="0" max="1" step="0.01" value="1">
      </div>

      <div class="control-group">
        <label>
          Text Green
          <span class="slider-value" id="greenValue">1.00</span>
        </label>
        <input type="range" id="greenSlider" min="0" max="1" step="0.01" value="1">
      </div>

      <div class="control-group">
        <label>
          Text Blue
          <span class="slider-value" id="blueValue">1.00</span>
        </label>
        <input type="range" id="blueSlider" min="0" max="1" step="0.01" value="1">
      </div>

      <div class="control-group">
        <label>Color Preview</label>
        <div class="color-preview" id="colorPreview"></div>
      </div>

      <div class="control-group">
        <label>
          Background Opacity
          <span class="slider-value" id="bgValue">0.00</span>
        </label>
        <input type="range" id="bgSlider" min="0" max="1" step="0.01" value="0">
      </div>
    </div>

    <div class="control-group">
      <button id="updateBtn">Update Parameters</button>
    </div>

    <div class="control-group">
      <label style="display:flex; justify-content:space-between; align-items:center;">
        Video Input
        <span id="webcamInfo" style="font-size:10px; color:#555; font-weight:400; text-transform:none; letter-spacing:0;">sends webcam to Scope as input</span>
      </label>
      <button id="webcamBtn" style="background:#333; color:#aaa; border:1px solid #555;">Webcam: OFF</button>
      <video id="webcamPreview" autoplay muted playsinline style="display:none; width:100%; margin-top:8px; border-radius:4px; border:1px solid #333;"></video>
    </div>

    <div class="control-group">
      <button id="autoBtn" style="background:#333; color:#aaa; border:1px solid #555;">Auto-update: OFF</button>
    </div>

    <div id="scopeStatus" style="padding:8px 10px;background:#111;border:1px solid #222;border-radius:4px;font-family:monospace;font-size:11px;color:#555;">
      Scope: ‚Äî
    </div>

    <div style="margin-top:20px;">
      <label style="display:flex; justify-content:space-between; align-items:center;">
        OSC LOG <span style="color:#555; font-size:10px; font-weight:400; text-transform:none; letter-spacing:0;">listening on UDP :9000</span>
        <span id="oscStatus" style="font-size:10px; color:#555; text-transform:none; letter-spacing:0;">‚óè not connected</span>
      </label>
      <div style="display:flex; gap:4px; margin-bottom:6px;">
        <button id="filterAll"     onclick="setFilter('all')"     style="width:auto;padding:4px 10px;font-size:11px;background:#00ff88;color:#000;border:none;">All</button>
        <button id="filterMapped"  onclick="setFilter('mapped')"  style="width:auto;padding:4px 10px;font-size:11px;background:#333;color:#aaa;border:1px solid #555;">Valid</button>
        <button id="filterUnknown" onclick="setFilter('unknown')" style="width:auto;padding:4px 10px;font-size:11px;background:#333;color:#aaa;border:1px solid #555;">Unknown</button>
        <button onclick="oscLog.innerHTML=''" style="width:auto;padding:4px 10px;font-size:11px;background:#333;color:#aaa;border:1px solid #555;margin-left:auto;">Clear</button>
      </div>
      <div id="oscLog" style="
        background:#111;
        border:1px solid #222;
        border-radius:4px;
        padding:8px;
        height:160px;
        overflow-y:auto;
        font-family:monospace;
        font-size:11px;
        color:#555;
        line-height:1.6;
      ">waiting for OSC...</div>
    </div>
  </div>

  <!-- Right-side params panel -->
  <div id="params-panel" style="
    width: 320px;
    background: #0d0d0d;
    border-left: 1px solid #222;
    padding: 20px;
    font-family: monospace;
    font-size: 12px;
    overflow-y: auto;
    flex-shrink: 0;
  ">
    <div style="color:#555; font-size:11px; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:12px; display:flex; justify-content:space-between; align-items:center;">
      Current Params
      <span id="paramsAge" style="font-size:10px; color:#333;">‚Äî</span>
    </div>
    <pre id="paramsDisplay" style="
      color: #00ff88;
      white-space: pre-wrap;
      word-break: break-all;
      margin: 0;
      line-height: 1.6;
    ">waiting...</pre>

  </div>

  <script>
    let API_BASE = "http://localhost:8000";
    const statusEl = document.getElementById("status");

    // Control elements
    const serverPortInput = document.getElementById("serverPort");
    const connectBtn = document.getElementById("connectBtn");
    const textInput = document.getElementById("textInput");
    const redSlider = document.getElementById("redSlider");
    const greenSlider = document.getElementById("greenSlider");
    const blueSlider = document.getElementById("blueSlider");
    const bgSlider = document.getElementById("bgSlider");
    const updateBtn = document.getElementById("updateBtn");
    const colorPreview = document.getElementById("colorPreview");

    // Value displays
    const redValue = document.getElementById("redValue");
    const greenValue = document.getElementById("greenValue");
    const blueValue = document.getElementById("blueValue");
    const bgValue = document.getElementById("bgValue");

    const pipelineSelect = document.getElementById("pipelineSelect");
    const promptInput = document.getElementById("promptInput");

    function updatePipelineUI() {
      const v = pipelineSelect.value;
      document.getElementById("ui-longlive").style.display    = v === "longlive"     ? "" : "none";
      document.getElementById("ui-passthrough").style.display  = v === "passthrough"  ? "" : "none";
      document.getElementById("ui-text-display").style.display = v === "text-display" ? "" : "none";
    }
    pipelineSelect.addEventListener("change", updatePipelineUI);
    updatePipelineUI();

    // --- NDI source picker ---
    const ndiSelect   = document.getElementById("ndiSelect");
    const ndiStatus   = document.getElementById("ndiStatus");
    const ndiRefreshBtn = document.getElementById("ndiRefreshBtn");

    async function refreshNDISources() {
      ndiRefreshBtn.textContent = "Scanning...";
      ndiRefreshBtn.disabled = true;
      ndiStatus.textContent = "Scanning for NDI sources (5s)‚Ä¶";
      try {
        const r = await fetch("/api/v1/input-sources/ndi/sources?timeout_ms=5000", { cache: "no-store" });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const { sources } = await r.json();
        ndiSelect.innerHTML = sources.length
          ? sources.map(s => `<option value="${s.identifier}">${s.name}</option>`).join("")
          : `<option value="">No NDI sources found</option>`;
        ndiStatus.textContent = sources.length ? `${sources.length} source(s) found` : "No sources found ‚Äî is NDI Out active?";
        ndiStatus.style.color = sources.length ? "#00ff88" : "#ff9900";
      } catch (e) {
        ndiStatus.textContent = `Error: ${e.message}`;
        ndiStatus.style.color = "#ff4444";
      } finally {
        ndiRefreshBtn.textContent = "Refresh";
        ndiRefreshBtn.disabled = false;
      }
    }

    ndiRefreshBtn.addEventListener("click", refreshNDISources);

    const SEND_INTERVAL_MS = 1000 / 60; // 60fps cap
    let lastSendTime = 0;
    let oscBatchTimer = null; // batches rapid OSC bursts into one Scope update

    // --- OSC log box ---
    const oscLog = document.getElementById("oscLog");
    const oscStatus = document.getElementById("oscStatus");

    let oscFilter = "all";

    function setFilter(f) {
      oscFilter = f;
      const btns = { all: "filterAll", mapped: "filterMapped", unknown: "filterUnknown" };
      Object.entries(btns).forEach(([key, id]) => {
        const btn = document.getElementById(id);
        const active = key === f;
        btn.style.background = active ? "#00ff88" : "#333";
        btn.style.color      = active ? "#000"    : "#aaa";
        btn.style.border     = active ? "none"    : "1px solid #555";
      });
      // Show/hide existing rows
      [...oscLog.querySelectorAll("div[data-type]")].forEach(el => {
        el.style.display = (oscFilter === "all" || el.dataset.type === oscFilter) ? "" : "none";
      });
    }

    function logOSC(data) {
      const time = new Date().toLocaleTimeString("en", { hour12: false });
      const line = document.createElement("div");
      let html, type;

      if (data._mapped === false) {
        // Unknown/unmapped address
        type = "unknown";
        html = `<span style="color:#444">${time}</span>  `
             + `<span style="color:#ff9900">${data._osc_address}</span> `
             + `<span style="color:#ffcc66">${data._osc_value}</span> `
             + `<span style="color:#555; font-size:10px;">‚ö† unmapped</span>`;
      } else {
        // Valid mapped address ‚Äî strip internal _mapped key
        type = "mapped";
        const fmt = v => typeof v === "number" ? v.toFixed(3) : typeof v === "object" ? JSON.stringify(v) : v;
        const entries = Object.entries(data)
          .filter(([k]) => !k.startsWith("_"))
          .map(([k, v]) =>
            `<span style="color:#00ff88">${k}</span> <span style="color:#fff">${fmt(v)}</span>`
          ).join("  ");
        html = `<span style="color:#444">${time}</span>  ${entries}`;
      }

      line.dataset.type = type;
      line.innerHTML = html;
      if (oscFilter !== "all" && type !== oscFilter) line.style.display = "none";

      // Clear placeholder text on first real message
      if (oscLog.firstChild && oscLog.firstChild.nodeType === Node.TEXT_NODE) oscLog.innerHTML = "";

      oscLog.appendChild(line);
      while (oscLog.children.length > 100) oscLog.removeChild(oscLog.firstChild);
      oscLog.scrollTop = oscLog.scrollHeight;
    }

    // --- WebSocket (receives OSC updates from server.py) ---
    function connectWebSocket() {
      const wsProto = location.protocol === "https:" ? "wss" : "ws";
      const wsUrl = `${wsProto}://${window.location.host}/ws`;
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        oscStatus.textContent = "‚óè connected";
        oscStatus.style.color = "#00ff88";
        oscLog.innerHTML = "";
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);

        // _from_ui means this is an echo of our own broadcast ‚Äî ignore it
        // to avoid a feedback loop where we re-send our own updates endlessly.
        if (data._from_ui) return;

        // Only apply params relevant to the currently selected pipeline.
        // This prevents /text OSC from triggering a longlive resend (and vice versa).
        if (data._mapped !== false) {
          const pipeline = pipelineSelect.value;
          if (pipeline === "text-display") {
            // text-display params
            let changed = false;
            if (data.text !== undefined)       { textInput.value   = data.text;              changed = true; }
            if (data.text_r !== undefined)     { redSlider.value   = data.text_r;            changed = true; }
            if (data.text_g !== undefined)     { greenSlider.value = data.text_g;            changed = true; }
            if (data.text_b !== undefined)     { blueSlider.value  = data.text_b;            changed = true; }
            if (data.bg_opacity !== undefined) { bgSlider.value    = data.bg_opacity;        changed = true; }
            if (changed) {
              updateDisplays();
              clearTimeout(oscBatchTimer);
              oscBatchTimer = setTimeout(sendParameters, 16);
            }
          } else if (pipeline === "longlive") {
            // longlive params ‚Äî update prompt input if /prompt OSC came in
            if (data.prompts?.[0]?.text !== undefined) {
              promptInput.value = data.prompts[0].text;
              // No need to resend ‚Äî viewer's data channel already got it from server
            }
          }
          // passthrough: no params to update
        }

        logOSC(data);
      };

      ws.onclose = () => {
        oscStatus.textContent = "‚óè disconnected";
        oscStatus.style.color = "#ff4444";
        setTimeout(connectWebSocket, 2000);
      };
    }

    connectWebSocket();

    // Update slider value displays and color preview
    function updateDisplays() {
      redValue.textContent = parseFloat(redSlider.value).toFixed(2);
      greenValue.textContent = parseFloat(greenSlider.value).toFixed(2);
      blueValue.textContent = parseFloat(blueSlider.value).toFixed(2);
      bgValue.textContent = parseFloat(bgSlider.value).toFixed(2);

      // Update color preview
      const r = Math.round(redSlider.value * 255);
      const g = Math.round(greenSlider.value * 255);
      const b = Math.round(blueSlider.value * 255);
      colorPreview.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    }

    // Auto-update toggle
    let autoUpdate = false;
    let debounceTimer = null;
    const autoBtn = document.getElementById("autoBtn");

    autoBtn.addEventListener('click', () => {
      autoUpdate = !autoUpdate;
      if (autoUpdate) {
        autoBtn.textContent = "Auto-update: ON";
        autoBtn.style.background = "#00ff88";
        autoBtn.style.color = "#000";
        autoBtn.style.border = "none";
      } else {
        autoBtn.textContent = "Auto-update: OFF";
        autoBtn.style.background = "#333";
        autoBtn.style.color = "#aaa";
        autoBtn.style.border = "1px solid #555";
      }
    });

    // Attach event listeners
    redSlider.addEventListener('input', () => { updateDisplays(); if (autoUpdate) sendParameters(); });
    greenSlider.addEventListener('input', () => { updateDisplays(); if (autoUpdate) sendParameters(); });
    blueSlider.addEventListener('input', () => { updateDisplays(); if (autoUpdate) sendParameters(); });
    bgSlider.addEventListener('input', () => { updateDisplays(); if (autoUpdate) sendParameters(); });

    // Send parameters to Scope.
    // Broadcasts via server.py so the viewer's data channel picks them up,
    // and also sends directly on the local data channel if it's open.
    function sendParameters() {
      const now = performance.now();
      if (now - lastSendTime < SEND_INTERVAL_MS) return;
      lastSendTime = now;

      const pipeline = pipelineSelect.value;
      const params = pipeline === "longlive" ? {
        pipeline_ids: ["longlive"],
        prompts: [{ text: promptInput.value, weight: 100 }],
        prompt_interpolation_method: "linear",
        denoising_step_list: [1000, 750, 500, 250]
      } : pipeline === "passthrough" ? (() => {
        const p = { pipeline_ids: ["passthrough"] };
        const ndiId = ndiSelect.value;
        if (ndiId) p.input_source = { source_type: "ndi", source_name: ndiId, enabled: true };
        return p;
      })() : {
        pipeline_ids: ["text-display"],
        text: textInput.value,
        text_r: parseFloat(redSlider.value),
        text_g: parseFloat(greenSlider.value),
        text_b: parseFloat(blueSlider.value),
        bg_opacity: parseFloat(bgSlider.value)
      };

      // Broadcast via server ‚Üí WebSocket ‚Üí viewer's data channel (primary path)
      fetch("/broadcast", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(params)
      }).catch(() => {});

    }

    // Update button click
    updateBtn.addEventListener('click', sendParameters);

    // Text input: Enter always sends; typing sends with debounce when auto-update is on
    textInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendParameters();
    });
    textInput.addEventListener('input', () => {
      if (!autoUpdate) return;
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(sendParameters, 300);
    });

    // Prompt input (longlive)
    promptInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendParameters();
    });
    promptInput.addEventListener('input', () => {
      if (!autoUpdate) return;
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(sendParameters, 300);
    });

    document.getElementById("resetCacheBtn").addEventListener("click", () => {
      fetch("/broadcast", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reset_cache: true })
      }).catch(() => {});
    });

    // Load pipeline and start streaming
    async function loadPipeline() {
      const pipelineId = pipelineSelect.value;
      statusEl.textContent = `Loading ${pipelineId} pipeline...`;

      await fetch(`${API_BASE}/api/v1/pipeline/load`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          pipeline_ids: [pipelineId]
        })
      });

      // Wait for pipeline to finish loading
      while (true) {
        const response = await fetch(`${API_BASE}/api/v1/pipeline/status`, { cache: "no-store" });
        const { status } = await response.json();

        if (status === "loaded") break;
        if (status === "error") throw new Error("Pipeline failed to load");

        await new Promise(r => setTimeout(r, 1000));
      }

      statusEl.textContent = "Pipeline loaded ‚úì";
    }

    async function connect() {
      const host = serverPortInput.value.trim() || "localhost:8000";
      // Tell the server which Scope host to proxy to, then use relative URLs
      await fetch("/config/scope", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ host })
      });
      API_BASE = "";
      connectBtn.disabled = true;
      connectBtn.textContent = "Connecting...";

      try {
        updateDisplays();
        await loadPipeline();
        // Broadcast initial params so viewer's data channel picks them up
        sendParameters();
        statusEl.textContent = "Connected";
        statusEl.className = "connected";
        connectBtn.textContent = "Reconnect";
        _scopeConnected = true;
        pollScopeStatus();
      } catch (error) {
        let msg = error.message;
        if (error instanceof TypeError && msg.includes("fetch")) {
          msg = `Cannot reach Scope at ${host} ‚Äî is Scope running? (uv run daydream-scope)`;
        } else if (msg.includes("Pipeline failed")) {
          msg = `Pipeline failed to load ‚Äî is the ${pipelineSelect.value} plugin installed?`;
        }
        statusEl.textContent = "‚ö†Ô∏è " + msg;
        statusEl.className = "error";
        console.error(error);
        connectBtn.textContent = "Connect";
      } finally {
        connectBtn.disabled = false;
      }
    }

    connectBtn.addEventListener("click", connect);

    // --- Webcam ‚Üí Scope WebRTC input ---
    const webcamBtn     = document.getElementById("webcamBtn");
    const webcamPreview = document.getElementById("webcamPreview");
    let _webcamStream   = null;
    let _webcamPc       = null;

    async function _startWebcamRTC() {
      if (!_webcamStream) return;
      try {
        const iceRes = await fetch("/api/v1/webrtc/ice-servers", { cache: "no-store" });
        const { iceServers } = await iceRes.json();
        const pc = new RTCPeerConnection({ iceServers });
        _webcamPc = pc;

        // Send our webcam video to Scope as pipeline input
        pc.addTrack(_webcamStream.getVideoTracks()[0], _webcamStream);
        // Accept Scope's output (required for SDP negotiation) ‚Äî assign to hidden element
        const sinkEl = document.createElement("video");
        sinkEl.autoplay = true; sinkEl.muted = true;
        pc.addTransceiver("video");
        pc.ontrack = (e) => { if (e.streams?.[0]) sinkEl.srcObject = e.streams[0]; };

        const dc = pc.createDataChannel("parameters", { ordered: true });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const queued = [];
        let sessionId = null;
        pc.onicecandidate = async (ev) => {
          if (!ev.candidate) return;
          if (sessionId) {
            await fetch(`/api/v1/webrtc/offer/${sessionId}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ candidates: [{ candidate: ev.candidate.candidate, sdpMid: ev.candidate.sdpMid, sdpMLineIndex: ev.candidate.sdpMLineIndex }] })
            });
          } else queued.push(ev.candidate);
        };

        const sdpRes = await fetch("/api/v1/webrtc/offer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type, initialParameters: {} })
        });
        const answer = await sdpRes.json();
        sessionId = answer.sessionId;
        await pc.setRemoteDescription({ type: answer.type, sdp: answer.sdp });

        if (queued.length) {
          await fetch(`/api/v1/webrtc/offer/${sessionId}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ candidates: queued.map(c => ({ candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex })) })
          });
        }

        pc.onconnectionstatechange = () => {
          if ((pc.connectionState === "failed" || pc.connectionState === "disconnected") && _webcamStream) {
            pc.close(); _webcamPc = null;
            setTimeout(_startWebcamRTC, 2000); // auto-reconnect
          }
        };
      } catch (e) {
        console.error("[Webcam RTC]", e);
        setTimeout(_startWebcamRTC, 3000);
      }
    }

    webcamBtn.addEventListener("click", async () => {
      if (_webcamStream) {
        // Turn off
        _webcamStream.getTracks().forEach(t => t.stop());
        _webcamStream = null;
        if (_webcamPc) { _webcamPc.close(); _webcamPc = null; }
        webcamPreview.srcObject = null;
        webcamPreview.style.display = "none";
        webcamBtn.textContent = "Webcam: OFF";
        webcamBtn.style.background = "#333"; webcamBtn.style.color = "#aaa"; webcamBtn.style.border = "1px solid #555";
      } else {
        // Turn on
        try {
          webcamBtn.textContent = "Webcam: starting...";
          _webcamStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          webcamPreview.srcObject = _webcamStream;
          webcamPreview.style.display = "block";
          webcamBtn.textContent = "Webcam: ON";
          webcamBtn.style.background = "#00ff88"; webcamBtn.style.color = "#000"; webcamBtn.style.border = "none";
          _startWebcamRTC();
        } catch (e) {
          webcamBtn.textContent = "Webcam: permission denied";
          _webcamStream = null;
        }
      }
    });

    // Initialize displays on load
    updateDisplays();

    // Poll Scope pipeline status every 2s ‚Äî only after user has connected
    const scopeStatusEl = document.getElementById("scopeStatus");
    let _scopeConnected = false;
    async function pollScopeStatus() {
      if (!_scopeConnected) return;
      try {
        const r = await fetch("/api/v1/pipeline/status", { cache: "no-store" });
        if (!r.ok) { scopeStatusEl.textContent = "Scope: unreachable"; return; }
        const d = await r.json();
        const state = d.status ?? "unknown";
        const pid = d.pipeline_id ?? "‚Äî";
        const err = d.error ? ` ‚ö† ${d.error}` : "";
        const color = state === "loaded" ? "#00ff88" : state === "error" ? "#ff4444" : "#ffaa00";
        scopeStatusEl.innerHTML = `Scope: <span style="color:${color}">${state}</span>  pipeline: <span style="color:#aaa">${pid}</span>${err}`;
      } catch (_) {
        scopeStatusEl.textContent = "Scope: unreachable";
      }
    }
    setInterval(pollScopeStatus, 2000);

    // Poll /params and display in right panel
    const paramsDisplay = document.getElementById("paramsDisplay");
    const paramsAge = document.getElementById("paramsAge");
    let lastParamsUpdate = null;

    async function pollParams() {
      try {
        const r = await fetch("/params", { cache: "no-store" });
        if (!r.ok) return;
        const d = await r.json();
        paramsDisplay.textContent = JSON.stringify(d, null, 2);
        lastParamsUpdate = Date.now();
      } catch (_) {}

    }

    // Update the age display every second
    setInterval(() => {
      if (lastParamsUpdate) {
        const s = Math.round((Date.now() - lastParamsUpdate) / 1000);
        paramsAge.textContent = s === 0 ? "just now" : `${s}s ago`;
      }
    }, 1000);

    setInterval(pollParams, 2000);
    pollParams();
  </script>
</body>
</html>
